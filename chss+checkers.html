<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess & Checkers & Blackjack</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS Variables for settings */
        :root {
            --piece-animation-speed: 0.2s; /* Default animation speed */
        }

        /* Custom styles for the game */
        body {
            font-family: 'Comic Sans MS', 'Comic Sans', cursive; /* Set font to Comic Sans */
            background: repeating-conic-gradient(
                from 0deg,
                #1a0a2a 0% 12.5%, /* Deep Space Dark Purple */
                #2a0a3a 12.5% 25%, /* Slightly Lighter Purple */
                #3a0a4a 25% 37.5%, /* Even Lighter Purple */
                #4a0a5a 37.5% 50%, /* Darkest Purple */
                #1a0a2a 50% 62.5%,\
                #2a0a3a 62.5% 75%,\
                #3a0a4a 75% 87.5%,\
                #4a0a5a 87.5% 100%
            ); /* New cool repeating conic pattern background for deep space feel */
            background-size: 800% 800%; /* Larger background for smoother animation */
            animation: background-gradient 60s linear infinite; /* Slower, linear animation for cosmic drift */
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: auto; /* Allow scrolling if content exceeds viewport */
        }

        /* Background animation for body */
        @keyframes background-gradient {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        .game-container {
            background-color: rgba(0, 0, 0, 0.7); /* Darker, more transparent */
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.6), inset 0 0 15px rgba(139, 92, 246, 0.3); /* Stronger outer glow, subtle inner glow */
            padding: 2.5rem; /* Slightly more padding */
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 90%; /* Max width for responsiveness */
            width: 600px; /* Max fixed width for desktop */
            border: 2px solid rgba(139, 92, 246, 0.5); /* Glowing border */
            backdrop-filter: blur(8px); /* More blur for frosted glass effect */
            color: #e0e0e0; /* Light text for dark background */
        }

        /* Chessboard specific styles */
        #chessboard {
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            max-width: 550px; /* Slightly increased max-width */
            aspect-ratio: 1 / 1; /* Ensure square aspect ratio */
            border: 4px solid #4a0a5a; /* Darker border for board */
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.4); /* Subtle board glow */
        }

        /* Checkers board specific styles */
        #checkersboard {
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            max-width: 550px; /* Slightly increased max-width */
            aspect-ratio: 1 / 1; /* Ensure square aspect ratio */
            border: 4px solid #4a0a5a; /* Darker border for board */
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.4); /* Subtle board glow */
        }
        
        /* Blackjack game container styles */
        #blackjack-game-container {
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 550px;
            padding: 20px;
            border-radius: 0.75rem;
            background-color: #004d00; /* Dark green for blackjack table */
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.4); /* Green glow */
        }

        /* Utility class to hide elements */
        .hidden-board {
            display: none !important;
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(1.5rem, 6vw, 3rem); /* Responsive font size for pieces */
            cursor: pointer;
            user-select: none; /* Prevent text selection on pieces */
            transition: background-color 0.2s ease;
        }

        /* New Board Colors */
        .chess-square.light, .checkers-square.light { background-color: #6d28d9; /* Deep Purple */ }
        .chess-square.dark, .checkers-square.dark { background-color: #1f2937; /* Dark Grey */ }


        .piece {
            font-size: clamp(1.5rem, 6vw, 3rem);
            line-height: 1;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
            transition: transform var(--piece-animation-speed) ease-in-out, box-shadow 0.2s ease;
            position: relative;
            z-index: 10;
        }

        /* Chess Pieces - New Colors & Glow */
        .chess-piece.white {
            color: #a78bfa; /* Light purple */
            filter: drop-shadow(0 0 5px #a78bfa); /* Glowing effect */
            text-shadow: 0 0 8px rgba(255,255,255,0.8);
        }
        .chess-piece.black {
            color: #f0f0f0; /* Bright white */
            filter: drop-shadow(0 0 5px #f0f0f0); /* Glowing effect */
            text-shadow: 0 0 8px rgba(0,0,0,0.8);
        }

        /* Checkers Pieces - New Colors & Orb Look */
        .checkers-piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(1rem, 4vw, 2rem);
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5); /* Deeper shadow */
            transition: transform var(--piece-animation-speed) ease-in-out, box-shadow 0.2s ease;
            position: relative;
            z-index: 10;
        }
        .checkers-piece.white {
            background-color: #a78bfa; /* Vibrant purple orb */
            border: 2px solid #8b5cf6;
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.7); /* Stronger glow */
            color: #fff; /* White text for contrast */
        }
        .checkers-piece.black {
            background-color: #1f2937; /* Dark grey for black pieces */
            border: 2px solid #374151;
            box-shadow: 0 0 15px rgba(31, 41, 55, 0.7); /* Stronger glow */
            color: #fff; /* White text for contrast */
        }
        .checkers-piece.king::after {
            content: '★'; /* Star indicator for king piece */
            position: absolute;
            font-size: 0.8em; /* Larger star */
            text-shadow: 0 0 5px rgba(255,255,0,0.8); /* Yellow glow for star */
        }
        .checkers-piece.white.king::after { color: #ffe082; } /* Yellowish star on purple */
        .checkers-piece.black.king::after { color: #ffa000; } /* Orangish star on dark grey */


        /* When a piece is being animated, it needs to be absolutely positioned */
        .piece.animating {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 100; /* Bring to front during animation */
        }

        /* Explode Animation for captured pieces */
        @keyframes explode {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
                filter: brightness(1);
            }
            50% {
                transform: scale(1.5) rotate(45deg);
                opacity: 0.8;
                filter: brightness(2) drop-shadow(0 0 10px yellow) drop-shadow(0 0 20px orange);
            }
            100% {
                transform: scale(0) rotate(90deg);
                opacity: 0;
                filter: brightness(0);
            }
        }

        .exploding {
            animation: explode 0.5s ease-out forwards; /* Apply explode animation */
        }


        .selected {
            background-color: #8b5cf6 !important; /* Purple for selected square */
            box-shadow: inset 0 0 0 4px #6d28d9; /* Inner border for selected */
        }

        .highlight-move {
            background-color: #4ade80 !important; /* Green for valid moves */
            position: relative;
        }

        .highlight-move::after {
            content: '';
            position: absolute;
            width: 25%;
            height: 25%;
            background-color: rgba(255, 255, 255, 0.3); /* Lighter dot for highlight */
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .highlight-capture {
            background-color: #ef4444 !important; /* Red for capture moves */
            position: relative;
        }

        .highlight-capture::after {
            content: '';
            position: absolute;
            width: 90%;
            height: 90%;
            border: 4px solid rgba(255, 255, 255, 0.5); /* White border for capture */
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .in-check {
            background-color: #f87171 !important; /* Light red for king in check */
            box-shadow: inset 0 0 0 5px #dc2626; /* Stronger red border */
        }

        button {
            padding: 12px 28px;
            font-weight: 700;
            border-radius: 0.75rem;
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            background-color: #4a0a5a; /* Dark purple button */
            color: #e0e0e0; /* Light text */
            border: 1px solid #6d28d9; /* Subtle border */
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(139, 92, 246, 0.5); /* Glowing shadow on hover */
            background-color: #6d28d9; /* Lighter purple on hover */
        }
        button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: #333;
            border-color: #555;
            box-shadow: none;
        }

        /* Responsive adjustments */
        @media (max-width: 640px) {
            .game-container {
                padding: 1rem;
                border-radius: 1rem;
            }
            #chessboard, #checkersboard, #blackjack-game-container {
                max-width: 95vw; /* Use viewport width on small screens */
            }
            .square {
                font-size: clamp(1.2rem, 8vw, 2.5rem); /* Adjust font size for smaller screens */
            }
            button {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
        }

        /* Modal Styles (General for Main Menu and Settings) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85); /* Very dark overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: rgba(0, 0, 0, 0.9); /* Even darker content background */
            padding: 2.5rem;
            border-radius: 1rem;
            box-shadow: 0 0 25px rgba(139, 92, 246, 0.5); /* Glowing shadow */
            width: 90%;
            max-width: 450px;
            position: relative;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
            text-align: center; /* Center content */
            border: 1px solid rgba(139, 92, 246, 0.3); /* Subtle glowing border */
            color: #e0e0e0; /* Light text */
        }
        .modal-overlay.active .modal-content {
            transform: translateY(0);
        }
        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #a78bfa; /* Light purple close button */
            transition: color 0.2s ease;
        }
        .modal-close-btn:hover {
            color: #c084fc; /* Lighter purple on hover */
        }
        .modal-content button {
            width: 100%;
            margin-bottom: 1rem; /* Space out buttons */
            background-color: #6d28d9; /* Purple buttons in modals */
            border-color: #8b5cf6;
        }
        .modal-content button:hover:not(:disabled) {
            background-color: #8b5cf6;
        }
        .modal-content h2 {
            color: #a78bfa; /* Light purple heading */
        }
        .modal-content label {
            color: #e0e0e0; /* Light text for labels */
        }
        .modal-content select, .modal-content input[type="range"] {
            background-color: #333;
            border-color: #555;
            color: #e0e0e0;
        }
        .modal-content select:focus, .modal-content input[type="range"]:focus {
            border-color: #a78bfa;
            box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.5);
        }

        /* Blackjack specific styles */
        .hand {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            min-height: 120px; /* To prevent layout shift when cards are added */
            flex-wrap: wrap;
        }

        .card {
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            width: 80px;
            height: 110px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            font-size: 1.2rem;
            font-weight: bold;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            color: black;
            position: relative;
            /* Add perspective for 3D transforms */
            transform-style: preserve-3d;
            backface-visibility: hidden; /* Hide back during flip */
        }

        .card.hidden-card {
            background-color: #555; /* Back of card */
            color: transparent;
            border: 1px dashed #777;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }

        .card-suit.red {
            color: red;
        }

        .card-rank {
            font-size: 1.5em;
        }
        .card-suit {
            font-size: 1.8em;
            position: absolute;
            bottom: 5px;
            right: 5px;
        }
        .card-suit.top-left {
            top: 5px;
            left: 5px;
            transform: rotate(180deg);
        }

        .blackjack-controls button {
            margin: 5px;
            width: auto;
            min-width: 120px;
        }
        .blackjack-info {
            margin-top: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            color: #e0e0e0;
        }
        .score-display {
            font-size: 1.5rem;
            margin-top: 10px;
            color: #a78bfa;
        }
        .chip-display {
            font-size: 1.4rem;
            font-weight: bold;
            color: #ffe082; /* Gold color for chips */
            margin-bottom: 10px;
            padding: 8px 15px;
            border-radius: 0.5rem;
            background-color: rgba(255, 215, 0, 0.1); /* Subtle gold background */
            border: 1px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        .bet-input-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .bet-input {
            width: 100px;
            padding: 8px 12px;
            border-radius: 0.5rem;
            border: 1px solid #6d28d9;
            background-color: #1f2937;
            color: #e0e0e0;
            font-size: 1.1rem;
            text-align: center;
        }
        .bet-input:focus {
            outline: none;
            border-color: #a78bfa;
            box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.5);
        }

        /* Animation for dealing cards */
        @keyframes deal-card-in {
            0% {
                opacity: 0;
                transform: translateY(50px) scale(0.8) rotateZ(-5deg);
                filter: brightness(0.5);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1) rotateZ(0deg);
                filter: brightness(1);
            }
        }

        /* Animation for flipping a card (dealer's hidden card) */
        @keyframes flip-card {
            0% {
                transform: rotateY(0deg);
                background-color: #555; /* Back of card color */
            }
            50% {
                transform: rotateY(90deg);
                background-color: #555; /* Still back of card */
            }
            50.01% { /* Instantly switch background at halfway point */
                background-color: white;
            }
            100% {
                transform: rotateY(0deg);
                background-color: white; /* Front of card color */
            }
        }

        .card.dealing {
            animation: deal-card-in 0.4s ease-out forwards;
        }

        .card.flipping {
            animation: flip-card 0.6s ease-in-out forwards;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">

    <div class="game-container w-full max-w-xl">
        <h1 id="game-title" class="text-4xl md:text-5xl font-extrabold text-purple-800 mb-6 text-center tracking-tight">
            Game Board
        </h1>
        <div id="status-message" class="mb-6 text-xl font-semibold text-gray-800 text-center">
            Ready to play!
        </div>

        <div id="board-container" class="w-full flex justify-center">
            <div id="chessboard" class="hidden-board"></div>
            <div id="checkersboard" class="hidden-board"></div>
            <div id="blackjack-game-container" class="hidden-board">
                <h2 class="text-2xl font-bold text-white mb-4">Blackjack</h2>

                <div id="player-chips" class="chip-display">Chips: $200</div>

                <div class="blackjack-section">
                    <h3 class="text-xl text-white">Dealer's Hand:</h3>
                    <div id="dealer-hand" class="hand"></div>
                    <div id="dealer-score" class="score-display">Score: 0</div>
                </div>

                <div class="blackjack-section mt-6">
                    <h3 class="text-xl text-white">Player's Hand:</h3>
                    <div id="player-hand" class="hand"></div>
                    <div id="player-score" class="score-display">Score: 0</div>
                </div>

                <div class="blackjack-info mt-6 text-center">
                    <span id="blackjack-status-message">Enter your bet and click Deal!</span>
                </div>

                <div class="bet-input-group mt-4">
                    <label for="bet-amount" class="text-white">Bet:</label>
                    <input type="number" id="bet-amount" class="bet-input" value="10" min="1" max="200">
                </div>

                <div class="blackjack-controls mt-6 flex justify-center flex-wrap">
                    <button id="deal-btn" class="bg-green-600 text-white">Deal</button>
                    <button id="hit-btn" class="bg-purple-600 text-white" disabled>Hit</button>
                    <button id="stand-btn" class="bg-red-600 text-white" disabled>Stand</button>
                    <button id="blackjack-new-game-btn" class="bg-blue-600 text-white">New Game</button>
                </div>
            </div>
        </div>

        <div class="mt-8 flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 w-full justify-center">
            <button id="new-game-btn" class="bg-purple-600 text-white hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
                New Game
            </button>
            <button id="reset-btn" class="bg-red-600 text-white hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75">
                Reset Board
            </button>
            <button id="settings-btn" class="bg-gray-600 text-white hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-75">
                Settings
            </button>
            <button id="main-menu-access-btn" class="bg-blue-600 text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75">
                Main Menu
            </button>
        </div>
    </div>

    <div id="main-menu-modal" class="modal-overlay active">
        <div class="modal-content">
            <h2 class="text-3xl font-bold text-purple-800 mb-6 text-center">Main Menu</h2>
            <button id="menu-play-chess-btn" class="bg-purple-600 text-white hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
                Play Chess
            </button>
            <button id="menu-play-checkers-btn" class="bg-green-600 text-white hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75">
                Play Checkers
            </button>
            <button id="menu-play-blackjack-btn" class="bg-indigo-600 text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75">
                Play Blackjack
            </button>
            <button id="menu-continue-game-btn" class="bg-blue-600 text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 disabled:opacity-50 disabled:cursor-not-allowed">
                Continue Game
            </button>
            <button id="menu-settings-btn" class="bg-gray-600 text-white hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-75">
                Settings
            </button>
        </div>
    </div>

    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn" id="close-settings-btn">&times;</button>
            <h2 class="text-3xl font-bold text-purple-800 mb-6 text-center">Settings</h2>

            <div class="mb-6">
                <label for="ai-difficulty" class="block text-gray-700 text-lg font-semibold mb-2">AI Difficulty:</label>
                <select id="ai-difficulty" class="w-full p-3 border border-gray-300 rounded-md focus:ring-purple-500 focus:border-purple-500">
                    <option value="1">Easy</option>
                    <option value="3" selected>Medium</option>
                    <option value="5">Hard</option>
                </select>
            </div>

            <div class="mb-6">
                <label for="animation-speed" class="block text-gray-700 text-lg font-semibold mb-2">Piece Animation Speed:</label>
                <input type="range" id="animation-speed" min="50" max="1000" value="200" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg" />
                <span id="animation-speed-value" class="block text-center text-gray-600 mt-2">0.2s</span>
            </div>

            <p class="text-sm text-gray-500 text-center">Changes are applied automatically.</p>
        </div>
    </div>

    <script>
        // JavaScript for the Chess & Checkers & Blackjack Game Logic

        // DOM Elements
        const gameTitleElement = document.getElementById('game-title');
        const boardContainer = document.getElementById('board-container');
        const statusMessageElement = document.getElementById('status-message');
        const newGameBtn = document.getElementById('new-game-btn');
        const resetBtn = document.getElementById('reset-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const mainMenuAccessBtn = document.getElementById('main-menu-access-btn'); // New button to open main menu from game

        // Main Menu Elements
        const mainMenuModal = document.getElementById('main-menu-modal');
        const menuPlayChessBtn = document.getElementById('menu-play-chess-btn');
        const menuPlayCheckersBtn = document.getElementById('menu-play-checkers-btn');
        const menuPlayBlackjackBtn = document.getElementById('menu-play-blackjack-btn'); // New Blackjack button
        const menuContinueGameBtn = document.getElementById('menu-continue-game-btn');
        const menuSettingsBtn = document.getElementById('menu-settings-btn');

        // Settings Modal Elements
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        const aiDifficultySelect = document.getElementById('ai-difficulty');
        const animationSpeedSlider = document.getElementById('animation-speed');
        const animationSpeedValueSpan = document.getElementById('animation-speed-value');

        // Blackjack DOM Elements
        const blackjackGameContainer = document.getElementById('blackjack-game-container');
        const dealerHandElement = document.getElementById('dealer-hand');
        const dealerScoreElement = document.getElementById('dealer-score');
        const playerHandElement = document.getElementById('player-hand');
        const playerScoreElement = document.getElementById('player-score');
        const blackjackStatusMessageElement = document.getElementById('blackjack-status-message');
        const dealBtn = document.getElementById('deal-btn');
        const hitBtn = document.getElementById('hit-btn');
        const standBtn = document.getElementById('stand-btn');
        const blackjackNewGameBtn = document.getElementById('blackjack-new-game-btn');
        const playerChipsElement = document.getElementById('player-chips'); // New chip display
        const betAmountInput = document.getElementById('bet-amount'); // New bet input


        // Global Game State Variables
        let currentGame = null; // Will hold either chessGame, checkersGame or blackjackGame object
        let gameInProgress = false; // Track if a game has been started
        let AI_DIFFICULTY_DEPTH = 3;
        let PIECE_ANIMATION_SPEED_MS = 200;
        const EXPLODE_ANIMATION_DURATION = 500; // Duration for the explode animation in ms


        // --- Helper Functions (Shared) ---

        /**
         * Generic function to move a piece with animation.
         * This function handles the visual animation and then updates the board state.
         * @param {Object} start - {row, col} of the starting square.
         * @param {Object} end - {row, col} of the ending square.
         * @param {Array<Array<Object|null>>} currentBoard - The board array.
         * @param {string} pieceClass - CSS class for the piece element (e.g., 'chess-piece', 'checkers-piece').
         * @param {Function} updateBoardStateAndRender - Callback to update the board array and re-render after animation.
         * @param {Object|null} capturedPieceInfo - Optional: {row, col, pieceClass} of the captured piece for explosion.
         * @returns {Promise<boolean>} Resolves true if move is valid and animated, false otherwise.
         */
        function animateAndMovePiece(start, end, currentBoard, pieceClass, updateBoardStateAndRender, capturedPieceInfo = null) {
            return new Promise(resolve => {
                const pieceToMove = currentBoard[start.row][start.col];
                if (!pieceToMove) {
                    resolve(false);
                    return;
                }

                const startSquareElement = document.querySelector(`[data-row="${start.row}"][data-col="${start.col}"]`);
                const pieceElement = startSquareElement ? startSquareElement.querySelector(`.${pieceClass}`) : null;

                if (!pieceElement) {
                    console.error("Piece element not found for animation at", start, "with class", pieceClass);
                    resolve(false);
                    return;
                }

                // Handle captured piece animation
                if (capturedPieceInfo) {
                    const capturedSquareElement = document.querySelector(`[data-row="${capturedPieceInfo.row}"][data-col="${capturedPieceInfo.col}"]`);
                    const capturedPieceElement = capturedSquareElement ? capturedSquareElement.querySelector(`.${capturedPieceInfo.pieceClass}`) : null;

                    if (capturedPieceElement) {
                        capturedPieceElement.classList.add('exploding');
                        // Remove captured piece from DOM after its explosion animation
                        setTimeout(() => {
                            if (capturedPieceElement && capturedPieceElement.parentNode) {
                                capturedPieceElement.parentNode.removeChild(capturedPieceElement);
                            }
                        }, EXPLODE_ANIMATION_DURATION);
                    }
                }

                // Calculate the translation needed for animation
                const startRect = startSquareElement.getBoundingClientRect();
                const endSquareElement = document.querySelector(`[data-row="${end.row}"][data-col="${end.col}"]`);
                const endRect = endSquareElement.getBoundingClientRect();

                // Get relative positions within the board container
                const boardElement = document.getElementById(currentGame.boardId);
                const boardRect = boardElement.getBoundingClientRect();
                const startX = startRect.left - boardRect.left;
                const startY = startRect.top - boardRect.top;
                const endX = endRect.left - boardRect.left;
                const endY = endRect.top - boardRect.top;

                const dx = endX - startX;
                const dy = endY - startY;

                // Apply transform for animation
                pieceElement.style.transform = `translate(${dx}px, ${dy}px)`;
                pieceElement.style.transition = `transform ${PIECE_ANIMATION_SPEED_MS / 1000}s ease-in-out`;
                pieceElement.style.zIndex = '100'; // Bring to front during animation

                setTimeout(() => {
                    // Reset transform and z-index after animation
                    pieceElement.style.transform = '';
                    pieceElement.style.transition = '';
                    pieceElement.style.zIndex = '';

                    // Now, update the actual board state and re-render
                    const moveSuccessful = updateBoardStateAndRender(start, end, pieceToMove);
                    resolve(moveSuccessful);
                }, PIECE_ANIMATION_SPEED_MS);
            });
        }


        // --- Chess Game Logic ---
        const chessGame = {
            boardId: 'chessboard',
            board: [],
            selectedSquare: null,
            currentPlayer: 'white',
            validMoves: [],
            whiteKingPosition: { row: 7, col: 4 },
            blackKingPosition: { row: 0, col: 4 },
            isAITurn: false,
            AI_PLAYER_COLOR: 'black',
            PIECES: {
                'white': { 'pawn': '♙', 'rook': '♖', 'knight': '♘', 'bishop': '♗', 'queen': '♕', 'king': '♔' },
                'black': { 'pawn': '♟', 'rook': '♜', 'knight': '♞', 'bishop': '♝', 'queen': '♛', 'king': '♚' }
            },
            PIECE_VALUES: { 'pawn': 10, 'knight': 30, 'bishop': 30, 'rook': 50, 'queen': 90, 'king': 900 },

            initializeBoard: function() {
                this.board = [
                    [{ type: 'rook', color: 'black' }, { type: 'knight', color: 'black' }, { type: 'bishop', color: 'black' }, { type: 'queen', color: 'black' }, { type: 'king', color: 'black' }, { type: 'bishop', color: 'black' }, { type: 'knight', color: 'black' }, { type: 'rook', color: 'black' }],
                    [{ type: 'pawn', color: 'black' }, { type: 'pawn', color: 'black' }, { type: 'pawn', color: 'black' }, { type: 'pawn', color: 'black' }, { type: 'pawn', color: 'black' }, { type: 'pawn', color: 'black' }, { type: 'pawn', color: 'black' }, { type: 'pawn', color: 'black' }],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [{ type: 'pawn', color: 'white' }, { type: 'pawn', color: 'white' }, { type: 'pawn', color: 'white' }, { type: 'pawn', color: 'white' }, { type: 'pawn', color: 'white' }, { type: 'pawn', color: 'white' }, { type: 'pawn', color: 'white' }, { type: 'pawn', color: 'white' }],
                    [{ type: 'rook', color: 'white' }, { type: 'knight', color: 'white' }, { type: 'bishop', color: 'white' }, { type: 'queen', color: 'white' }, { type: 'king', color: 'white' }, { type: 'bishop', color: 'white' }, { type: 'knight', color: 'white' }, { type: 'rook', color: 'white' }]
                ];
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.validMoves = [];
                this.whiteKingPosition = { row: 7, col: 4 };
                this.blackKingPosition = { row: 0, col: 4 };
                this.isAITurn = false;
                console.log("Chess board initialized with:", this.board.flat().filter(p => p !== null).length, "pieces.");
            },

            renderBoard: function() {
                const chessboardElement = document.getElementById(this.boardId);
                if (!chessboardElement) return; // Ensure board element exists
                chessboardElement.innerHTML = '';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const square = document.createElement('div');
                        square.classList.add('square', 'chess-square', (r + c) % 2 === 0 ? 'light' : 'dark');
                        square.dataset.row = r;
                        square.dataset.col = c;

                        const piece = this.board[r][c];
                        if (piece) {
                            const pieceElement = document.createElement('span');
                            pieceElement.classList.add('piece', 'chess-piece', piece.color);
                            pieceElement.textContent = this.PIECES[piece.color][piece.type];
                            square.appendChild(pieceElement);
                        }

                        if (this.selectedSquare && this.selectedSquare.row === r && this.selectedSquare.col === c) {
                            square.classList.add('selected');
                        }
                        if (this.validMoves.some(move => move.row === r && move.col === c)) {
                            const targetPiece = this.board[r][c];
                            if (targetPiece && targetPiece.color !== this.currentPlayer) {
                                square.classList.add('highlight-capture');
                            } else {
                                square.classList.add('highlight-move');
                            }
                        }

                        const pieceOnSquare = this.board[r][c];
                        if (pieceOnSquare && pieceOnSquare.type === 'king') {
                            if (pieceOnSquare.color === 'white' && this.isKingInCheck('white', this.board, this.whiteKingPosition, this.blackKingPosition)) {
                                square.classList.add('in-check');
                            } else if (pieceOnSquare.color === 'black' && this.isKingInCheck('black', this.board, this.whiteKingPosition, this.blackKingPosition)) {
                                square.classList.add('in-check');
                            }
                        }

                        square.addEventListener('click', this.handleSquareClick.bind(this));
                        chessboardElement.appendChild(square);
                    }
                }
                this.updateStatusMessage();
            },

            updateStatusMessage: function() {
                let message = `${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)} to move.`;
                if (this.isKingInCheck(this.currentPlayer, this.board, this.whiteKingPosition, this.blackKingPosition)) {
                    message += ` ${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)} King is in CHECK!`;
                }
                statusMessageElement.textContent = message;
            },

            handleSquareClick: async function(event) {
                if (this.isAITurn) return;

                const row = parseInt(event.currentTarget.dataset.row);
                const col = parseInt(event.currentTarget.dataset.col);
                const clickedPiece = this.board[row][col];

                if (this.selectedSquare) {
                    if (this.selectedSquare.row === row && this.selectedSquare.col === col) {
                        this.selectedSquare = null;
                        this.validMoves = [];
                        this.renderBoard();
                        return;
                    }

                    if (this.validMoves.some(move => move.row === row && move.col === col)) {
                        let capturedPieceInfo = null;
                        const targetPiece = this.board[row][col];
                        if (targetPiece && targetPiece.color !== this.currentPlayer) {
                            capturedPieceInfo = { row, col, pieceClass: 'chess-piece' };
                        }

                        const moveSuccessful = await animateAndMovePiece(
                            this.selectedSquare,
                            { row, col },
                            this.board,
                            'chess-piece',
                            this.updateBoardStateAndRender.bind(this),
                            capturedPieceInfo
                        );
                        this.selectedSquare = null;
                        this.validMoves = [];

                        if (moveSuccessful && this.currentPlayer === this.AI_PLAYER_COLOR) {
                            this.isAITurn = true;
                            setTimeout(this.makeAIMove.bind(this), PIECE_ANIMATION_SPEED_MS + 500);
                        } else if (moveSuccessful) {
                            this.renderBoard();
                        }
                    } else {
                        if (clickedPiece && clickedPiece.color === this.currentPlayer) {
                            this.selectedSquare = { row, col };
                            this.validMoves = this.getValidMoves(this.selectedSquare, this.board, this.whiteKingPosition, this.blackKingPosition);
                        } else {
                            this.selectedSquare = null;
                            this.validMoves = [];
                        }
                    }
                } else {
                    if (clickedPiece && clickedPiece.color === this.currentPlayer) {
                        this.selectedSquare = { row, col };
                        this.validMoves = this.getValidMoves(this.selectedSquare, this.board, this.whiteKingPosition, this.blackKingPosition);
                    }
                }
                this.renderBoard();
            },

            updateBoardStateAndRender: function(start, end, pieceToMove) {
                const originalTargetPiece = this.board[end.row][end.col];
                const originalStartPiece = this.board[start.row][start.col];
                const originalWhiteKingPos = { ...this.whiteKingPosition };
                const originalBlackKingPos = { ...this.blackKingPosition };

                this.board[end.row][end.col] = pieceToMove;
                this.board[start.row][start.col] = null;

                if (pieceToMove.type === 'king') {
                    if (pieceToMove.color === 'white') {
                        this.whiteKingPosition = end;
                    } else {
                        this.blackKingPosition = end;
                    }
                }

                if (this.isKingInCheck(pieceToMove.color, this.board, this.whiteKingPosition, this.blackKingPosition)) {
                    this.board[start.row][start.col] = originalStartPiece;
                    this.board[end.row][end.col] = originalTargetPiece;
                    this.whiteKingPosition = originalWhiteKingPos;
                    this.blackKingPosition = originalBlackKingPos;
                    statusMessageElement.textContent = `Invalid move! ${pieceToMove.color.charAt(0).toUpperCase() + pieceToMove.color.slice(1)} King would be in check.`;
                    this.renderBoard();
                    return false;
                }

                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                this.renderBoard();
                return true;
            },

            getRawMoves: function(start, piece, currentBoard) {
                let moves = [];
                switch (piece.type) {
                    case 'pawn': moves = this.getRawPawnMoves(start, piece.color, currentBoard); break;
                    case 'rook': moves = this.getRawStraightLineMoves(start, piece.color, currentBoard); break;
                    case 'knight': moves = this.getRawKnightMoves(start, piece.color, currentBoard); break;
                    case 'bishop': moves = this.getRawDiagonalMoves(start, piece.color, currentBoard); break;
                    case 'queen': moves = this.getRawStraightLineMoves(start, piece.color, currentBoard).concat(this.getRawDiagonalMoves(start, piece.color, currentBoard)); break;
                    case 'king': moves = this.getRawKingMoves(start, piece.color, currentBoard); break;
                }
                return moves;
            },

            getRawPawnMoves: function(start, color, currentBoard) {
                const moves = [];
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                const newRow = start.row + direction;
                if (newRow >= 0 && newRow < 8 && !currentBoard[newRow][start.col]) {
                    moves.push({ row: newRow, col: start.col });
                    if (start.row === startRow) {
                        const doubleStepRow = start.row + 2 * direction;
                        if (!currentBoard[doubleStepRow][start.col]) { moves.push({ row: doubleStepRow, col: start.col }); }
                    }
                }
                const captureCols = [start.col - 1, start.col + 1];
                captureCols.forEach(c => {
                    if (c >= 0 && c < 8) {
                        const targetPiece = currentBoard[newRow]?.[c];
                        if (targetPiece && targetPiece.color !== color) { moves.push({ row: newRow, col: c }); }
                    }
                });
                return moves;
            },
            getRawStraightLineMoves: function(start, color, currentBoard) {
                const moves = [];
                const directions = [{ dr: -1, dc: 0 }, { dr: 1, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }];
                directions.forEach(dir => {
                    for (let i = 1; i < 8; i++) {
                        const newRow = start.row + dir.dr * i;
                        const newCol = start.col + dir.dc * i;
                        if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                        const targetPiece = currentBoard[newRow][newCol];
                        if (targetPiece) {
                            if (targetPiece.color !== color) { moves.push({ row: newRow, col: newCol }); }
                            break;
                        }
                        moves.push({ row: newRow, col: newCol });
                    }
                });
                return moves;
            },
            getRawDiagonalMoves: function(start, color, currentBoard) {
                const moves = [];
                const directions = [{ dr: -1, dc: -1 }, { dr: -1, dc: 1 }, { dr: 1, dc: -1 }, { dr: 1, dc: 1 }];
                directions.forEach(dir => {
                    for (let i = 1; i < 8; i++) {
                        const newRow = start.row + dir.dr * i;
                        const newCol = start.col + dir.dc * i;
                        if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                        const targetPiece = currentBoard[newRow][newCol];
                        if (targetPiece) {
                            if (targetPiece.color !== color) { moves.push({ row: newRow, col: newCol }); }
                            break;
                        }
                        moves.push({ row: newRow, col: newCol });
                    }
                });
                return moves;
            },
            getRawKnightMoves: function(start, color, currentBoard) {
                const moves = [];
                const knightOffsets = [{ dr: -2, dc: -1 }, { dr: -2, dc: 1 }, { dr: -1, dc: -2 }, { dr: -1, dc: 2 }, { dr: 1, dc: -2 }, { dr: 1, dc: 2 }, { dr: 2, dc: -1 }, { dr: 2, dc: 1 }];
                knightOffsets.forEach(offset => {
                    const newRow = start.row + offset.dr;
                    const newCol = start.col + offset.dc;
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        const targetPiece = currentBoard[newRow][newCol];
                        if (!targetPiece || targetPiece.color !== color) { moves.push({ row: newRow, col: newCol }); }
                    }
                });
                return moves;
            },
            getRawKingMoves: function(start, color, currentBoard) {
                const moves = [];
                const kingOffsets = [{ dr: -1, dc: -1 }, { dr: -1, dc: 0 }, { dr: -1, dc: 1 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }, { dr: 1, dc: -1 }, { dr: 1, dc: 0 }, { dr: 1, dc: 1 }];
                kingOffsets.forEach(offset => {
                    const newRow = start.row + offset.dr;
                    const newCol = start.col + offset.dc;
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        const targetPiece = currentBoard[newRow][newCol];
                        if (!targetPiece || targetPiece.color !== color) { moves.push({ row: newRow, col: newCol }); }
                    }
                });
                return moves;
            },

            isSquareAttacked: function(row, col, attackingColor, currentBoard) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = currentBoard[r][c];
                        if (piece && piece.color === attackingColor) {
                            const rawMoves = this.getRawMoves({ row: r, col: c }, piece, currentBoard);
                            if (rawMoves.some(move => move.row === row && move.col === col)) { return true; }
                        }
                    }
                }
                return false;
            },

            isKingInCheck: function(kingColor, currentBoard, currentWhiteKingPos, currentBlackKingPos) {
                const kingPos = kingColor === 'white' ? currentWhiteKingPos : currentBlackKingPos;
                const attackingColor = kingColor === 'white' ? 'black' : 'white';
                return this.isSquareAttacked(kingPos.row, kingPos.col, attackingColor, currentBoard);
            },

            getValidMoves: function(start, currentBoard, currentWhiteKingPos, currentBlackKingPos) {
                const piece = currentBoard[start.row][start.col];
                if (!piece) { return []; }
                const rawMoves = this.getRawMoves(start, piece, currentBoard);
                const filteredMoves = rawMoves.filter(end => {
                    const simulatedBoard = JSON.parse(JSON.stringify(currentBoard));
                    const simulatedWhiteKingPos = { ...currentWhiteKingPos };
                    const simulatedBlackKingPos = { ...currentBlackKingPos };
                    const pieceToMove = simulatedBoard[start.row][start.col];
                    simulatedBoard[end.row][end.col] = pieceToMove;
                    simulatedBoard[start.row][start.col] = null;
                    if (pieceToMove.type === 'king') {
                        if (pieceToMove.color === 'white') { simulatedWhiteKingPos.row = end.row; simulatedWhiteKingPos.col = end.col; }
                        else { simulatedBlackKingPos.row = end.row; simulatedBlackKingPos.col = end.col; }
                    }
                    return !this.isKingInCheck(piece.color, simulatedBoard, simulatedWhiteKingPos, simulatedBlackKingPos);
                });
                return filteredMoves;
            },

            evaluateBoard: function(currentBoard) {
                let score = 0;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = currentBoard[r][c];
                        if (piece) {
                            const pieceValue = this.PIECE_VALUES[piece.type];
                            if (piece.color === 'white') { score += pieceValue; }
                            else { score -= pieceValue; }
                        }
                    }
                }
                return score;
            },

            minimax: function(currentBoard, depth, isMaximizingPlayer, currentWhiteKingPos, currentBlackKingPos) {
                if (depth === 0) { return this.evaluateBoard(currentBoard); }
                const currentPlayerForMinimax = isMaximizingPlayer ? this.AI_PLAYER_COLOR : (this.AI_PLAYER_COLOR === 'white' ? 'black' : 'white');
                let allLegalMoves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = currentBoard[r][c];
                        if (piece && piece.color === currentPlayerForMinimax) {
                            const pieceMoves = this.getValidMoves({ row: r, col: c }, currentBoard, currentWhiteKingPos, currentBlackKingPos);
                            pieceMoves.forEach(move => allLegalMoves.push({ start: { row: r, col: c }, end: move }));
                        }
                    }
                }
                if (allLegalMoves.length === 0) { return this.evaluateBoard(currentBoard); }

                if (isMaximizingPlayer) {
                    let minEval = Infinity;
                    for (const move of allLegalMoves) {
                        const newBoard = JSON.parse(JSON.stringify(currentBoard));
                        const pieceToMove = newBoard[move.start.row][move.start.col];
                        newBoard[move.end.row][move.end.col] = pieceToMove;
                        newBoard[move.start.row][move.start.col] = null;
                        let nextWhiteKingPos = { ...currentWhiteKingPos };
                        let nextBlackKingPos = { ...currentBlackKingPos };
                        if (pieceToMove.type === 'king') {
                            if (pieceToMove.color === 'white') { nextWhiteKingPos = move.end; }
                            else { nextBlackKingPos = move.end; }
                        }
                        const evaluation = this.minimax(newBoard, depth - 1, false, nextWhiteKingPos, nextBlackKingPos);
                        minEval = Math.min(minEval, evaluation);
                    }
                    return minEval;
                } else {
                    let maxEval = -Infinity;
                    for (const move of allLegalMoves) {
                        const newBoard = JSON.parse(JSON.stringify(currentBoard));
                        const pieceToMove = newBoard[move.start.row][move.start.col];
                        newBoard[move.end.row][move.end.col] = pieceToMove;
                        newBoard[move.start.row][move.start.col] = null;
                        let nextWhiteKingPos = { ...currentWhiteKingPos };
                        let nextBlackKingPos = { ...currentBlackKingPos };
                        if (pieceToMove.type === 'king') {
                            if (pieceToMove.color === 'white') { nextWhiteKingPos = move.end; }
                            else { nextBlackKingPos = move.end; }
                        }
                        const evaluation = this.minimax(newBoard, depth - 1, true, nextWhiteKingPos, nextBlackKingPos);
                        maxEval = Math.max(maxEval, evaluation);
                    }
                    return maxEval;
                }
            },

            findBestMove: function() {
                let bestMove = null;
                let bestEval = Infinity;
                const allLegalMoves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece && piece.color === this.AI_PLAYER_COLOR) {
                            const pieceMoves = this.getValidMoves({ row: r, col: c }, this.board, this.whiteKingPosition, this.blackKingPosition);
                            pieceMoves.forEach(move => allLegalMoves.push({ start: { row: r, col: c }, end: move }));
                        }
                    }
                }
                if (allLegalMoves.length === 0) { console.log("AI has no legal moves."); return null; }

                for (const move of allLegalMoves) {
                    const newBoard = JSON.parse(JSON.stringify(this.board));
                    const pieceToMove = newBoard[move.start.row][move.start.col];
                    newBoard[move.end.row][move.end.col] = pieceToMove;
                    newBoard[move.start.row][move.start.col] = null;
                    let nextWhiteKingPos = { ...this.whiteKingPosition };
                    let nextBlackKingPos = { ...this.blackKingPosition };
                    if (pieceToMove.type === 'king') {
                        if (pieceToMove.color === 'white') { nextWhiteKingPos = move.end; }
                        else { nextBlackKingPos = move.end; }
                    }
                    const evaluation = this.minimax(newBoard, AI_DIFFICULTY_DEPTH - 1, false, nextWhiteKingPos, nextBlackKingPos);
                    if (evaluation < bestEval) {
                        bestEval = evaluation;
                        bestMove = move;
                    }
                }
                return bestMove;
            },

            makeAIMove: async function() {
                statusMessageElement.textContent = "AI (Black) is thinking...";
                this.disableInteraction();
                await new Promise(resolve => setTimeout(resolve, 1000));
                const move = this.findBestMove();
                if (move) {
                    let capturedPieceInfo = null;
                    const targetPiece = this.board[move.end.row][move.end.col];
                    if (targetPiece && targetPiece.color !== this.AI_PLAYER_COLOR) {
                        capturedPieceInfo = { row: move.end.row, col: move.end.col, pieceClass: 'chess-piece' };
                    }

                    const moveSuccessful = await animateAndMovePiece(
                        move.start,
                        move.end,
                        this.board,
                        'chess-piece',
                        this.updateBoardStateAndRender.bind(this),
                        capturedPieceInfo
                    );
                    if (moveSuccessful) { /* renderBoard is called in updateBoardStateAndRender */ }
                    else { console.error("AI attempted an invalid move after calculation."); }
                } else {
                    console.log("AI has no legal moves. Game might be over (checkmate/stalemate).");
                    statusMessageElement.textContent = "AI has no legal moves. Game over!";
                }
                this.isAITurn = false;
                this.enableInteraction();
                this.renderBoard();
            },

            disableInteraction: function() {
                document.getElementById(this.boardId).style.pointerEvents = 'none';
                newGameBtn.disabled = true;
                resetBtn.disabled = true;
                settingsBtn.disabled = true;
                mainMenuAccessBtn.disabled = true;
            },

            enableInteraction: function() {
                document.getElementById(this.boardId).style.pointerEvents = 'auto';
                newGameBtn.disabled = false;
                resetBtn.disabled = false;
                settingsBtn.disabled = false;
                mainMenuAccessBtn.disabled = false;
            }
        };

        // --- Checkers Game Logic ---
        const checkersGame = {
            boardId: 'checkersboard',
            board: [],
            selectedSquare: null,
            currentPlayer: 'white',
            validMoves: [],
            mustCapture: false, // Flag for mandatory captures
            lastJumpedPiece: null, // To track multi-jumps
            PIECES: {
                'white': { 'pawn': '', 'king': '★' }, // Checkers pieces are circles, '★' for king
                'black': { 'pawn': '', 'king': '★' }
            },
            AI_PLAYER_COLOR: 'black', // Define AI player color for Checkers

            initializeBoard: function() {
                console.log("Starting Checkers game initialization...");
                this.board = Array(8).fill(null).map(() => Array(8).fill(null));
                for (let r = 0; r < 3; r++) {
                    for (let c = 0; c < 8; c++) {
                        if ((r + c) % 2 !== 0) { // Dark squares
                            this.board[r][c] = { type: 'pawn', color: 'black' };
                        }
                    }
                }
                for (let r = 5; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if ((r + c) % 2 !== 0) { // Dark squares
                            this.board[r][c] = { type: 'pawn', color: 'white' };
                        }
                    }
                }
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.validMoves = [];
                this.mustCapture = false;
                this.lastJumpedPiece = null;
                this.isAITurn = false; // Initialize AI turn flag
                console.log("Checkers board initialized with:", this.board.flat().filter(p => p !== null).length, "pieces.");
            },

            renderBoard: function() {
                console.log("Checkers board rendering...");
                const checkersboardElement = document.getElementById(this.boardId);
                if (!checkersboardElement) {
                    console.error("Checkers board element not found!");
                    return;
                }
                checkersboardElement.innerHTML = ''; // Clear existing board
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const square = document.createElement('div');
                        // Checkers squares are dark if (r + c) is odd, light if even
                        square.classList.add('square', 'checkers-square', (r + c) % 2 === 0 ? 'light' : 'dark');
                        square.dataset.row = r;
                        square.dataset.col = c;
                        console.log("Created square:", r, c);

                        const piece = this.board[r][c];
                        if (piece) {
                            const pieceElement = document.createElement('span');
                            pieceElement.classList.add('checkers-piece', piece.color);
                            if (piece.type === 'king') {
                                pieceElement.classList.add('king');
                                pieceElement.textContent = this.PIECES[piece.color][piece.type]; // Set star content
                            }
                            square.appendChild(pieceElement);
                            console.log("Placed piece:", piece.color, piece.type);
                        }

                        // Highlight selected piece
                        if (this.selectedSquare && this.selectedSquare.row === r && this.selectedSquare.col === c) {
                            square.classList.add('selected');
                        }
                        // Highlight valid moves/jumps
                        if (this.validMoves.some(move => move.row === r && move.col === c)) {
                            // Checkers captures always land on empty square after jump, so no targetPiece check needed for highlight-capture
                            square.classList.add('highlight-move'); // Use highlight-move for valid jump landings
                        }

                        square.addEventListener('click', this.handleSquareClick.bind(this));
                        checkersboardElement.appendChild(square);
                    }
                }
                this.updateStatusMessage();
            },

            updateStatusMessage: function() {
                let message = `${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)} to move.`;
                if (this.mustCapture) {
                    message += " (Mandatory Capture!)";
                }
                statusMessageElement.textContent = message;
            },

            handleSquareClick: async function(event) {
                if (this.isAITurn) return;

                const row = parseInt(event.currentTarget.dataset.row);
                const col = parseInt(event.currentTarget.dataset.col);
                const clickedPiece = this.board[row][col];
                console.log("Clicked square:", { row, col });

                // If multi-jump is active, only allow clicking the last jumped piece
                if (this.lastJumpedPiece && (this.lastJumpedPiece.row !== row || this.lastJumpedPiece.col !== col)) {
                    // If clicking a different piece or a non-valid square while multi-jumping, ignore
                    if (!this.validMoves.some(move => move.row === row && move.col === col)) {
                        return;
                    }
                }

                if (this.selectedSquare) {
                    if (this.selectedSquare.row === row && this.selectedSquare.col === col && !this.mustCapture) {
                        // Deselect unless a capture is mandatory (then must re-select same piece to jump)
                        this.selectedSquare = null;
                        this.validMoves = [];
                        this.renderBoard();
                        return;
                    }

                    if (this.validMoves.some(move => move.row === row && move.col === col)) {
                        let capturedPieceInfo = null;
                        const potentialJumpedRow = (this.selectedSquare.row + row) / 2;
                        const potentialJumpedCol = (this.selectedSquare.col + col) / 2;

                        // Check if it's a jump and if there's a piece to capture
                        if (Math.abs(this.selectedSquare.row - row) === 2 && this.board[potentialJumpedRow][potentialJumpedCol]) {
                            capturedPieceInfo = { row: potentialJumpedRow, col: potentialJumpedCol, pieceClass: 'checkers-piece' };
                        }

                        // Valid move/jump
                        const moveSuccessful = await animateAndMovePiece(
                            this.selectedSquare,
                            { row, col },
                            this.board,
                            'checkers-piece',
                            this.updateBoardStateAndRender.bind(this),
                            capturedPieceInfo
                        );

                        if (moveSuccessful) {
                            // After move, check for further jumps if it was a capture
                            if (moveSuccessful.isJump) {
                                const furtherJumps = this.getValidMoves({ row, col }, this.board, true); // Check for jumps from new position
                                if (furtherJumps.length > 0) {
                                    this.selectedSquare = { row, col }; // Keep piece selected for multi-jump
                                    this.validMoves = furtherJumps;
                                    this.mustCapture = true;
                                    this.lastJumpedPiece = { row, col };
                                    this.renderBoard();
                                    return; // Stay on current player's turn for multi-jump
                                }
                            }
                            // If no further jumps or not a jump, end turn
                            this.selectedSquare = null;
                            this.validMoves = [];
                            this.mustCapture = false;
                            this.lastJumpedPiece = null;

                            if (this.currentPlayer === this.AI_PLAYER_COLOR) {
                                this.isAITurn = true;
                                setTimeout(this.makeAIMove.bind(this), PIECE_ANIMATION_SPEED_MS + 500);
                            }
                        }
                    } else {
                        // Not a valid move for the selected piece, try to select new piece
                        if (clickedPiece && clickedPiece.color === this.currentPlayer && !this.mustCapture) {
                            this.selectedSquare = { row, col };
                            this.validMoves = this.getValidMoves(this.selectedSquare, this.board, false); // Check for initial moves
                            this.mustCapture = this.validMoves.some(move => move.isJump);
                            // If mandatory capture, filter validMoves to only include jumps
                            if (this.mustCapture) {
                                this.validMoves = this.validMoves.filter(move => move.isJump);
                            }
                        } else if (this.mustCapture && this.selectedSquare.row === row && this.selectedSquare.col === col) {
                             // Re-clicked same piece during mandatory capture, allow re-selection
                             this.validMoves = this.getValidMoves(this.selectedSquare, this.board, true); // Only jumps from this piece
                        } else {
                            this.selectedSquare = null;
                            this.validMoves = [];
                            this.mustCapture = false; // Reset if deselected
                            this.lastJumpedPiece = null;
                        }
                    }
                } else {
                    // No piece selected, try to select one
                    if (clickedPiece && clickedPiece.color === this.currentPlayer) {
                        this.selectedSquare = { row, col };
                        this.validMoves = this.getValidMoves(this.selectedSquare, this.board, false);
                        this.mustCapture = this.validMoves.some(move => move.isJump);
                        if (this.mustCapture) {
                            this.validMoves = this.validMoves.filter(move => move.isJump);
                        }
                    }
                }
                this.renderBoard();
            },

            updateBoardStateAndRender: function(start, end, pieceToMove) {
                let isJump = false;
                // Calculate if it was a jump (distance > 1)
                if (Math.abs(start.row - end.row) === 2) {
                    isJump = true;
                    const jumpedRow = (start.row + end.row) / 2;
                    const jumpedCol = (start.col + end.col) / 2;
                    this.board[jumpedRow][jumpedCol] = null; // Remove captured piece
                }

                this.board[end.row][end.col] = pieceToMove;
                this.board[start.row][start.col] = null;

                // Check for kinging
                if (pieceToMove.type === 'pawn') {
                    if ((pieceToMove.color === 'white' && end.row === 0) || (pieceToMove.color === 'black' && end.row === 7)) {
                        this.board[end.row][end.col].type = 'king';
                        console.log(`${pieceToMove.color} pawn kinged at ${end.row},${end.col}`);
                    }
                }

                // Only switch player if not a jump or no further jumps
                if (!isJump || this.getValidMoves(end, this.board, true).length === 0) {
                    this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                }

                this.renderBoard();
                return { success: true, isJump: isJump };
            },

            getValidMoves: function(start, currentBoard, onlyJumps = false) {
                const moves = [];
                const piece = currentBoard[start.row][start.col];
                if (!piece) return [];

                const directions = piece.type === 'king' ?
                    [{ dr: -1, dc: -1 }, { dr: -1, dc: 1 }, { dr: 1, dc: -1 }, { dr: 1, dc: 1 }] : // King: all 4 diagonals
                    (piece.color === 'white' ?
                        [{ dr: -1, dc: -1 }, { dr: -1, dc: 1 }] : // White pawn: forward diagonals
                        [{ dr: 1, dc: -1 }, { dr: 1, dc: 1 }]); // Black pawn: forward diagonals

                directions.forEach(dir => {
                    const newRow = start.row + dir.dr;
                    const newCol = start.col + dir.dc;
                    const jumpRow = start.row + 2 * dir.dr;
                    const jumpCol = start.col + 2 * dir.dc;

                    // Check for jumps
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        const targetPiece = currentBoard[newRow][newCol];
                        if (targetPiece && targetPiece.color !== piece.color) { // Opponent's piece
                            if (jumpRow >= 0 && jumpRow < 8 && jumpCol >= 0 && jumpCol < 8 && !currentBoard[jumpRow][jumpCol]) { // Landing square is empty
                                moves.push({ row: jumpRow, col: jumpCol, isJump: true, captured: { row: newRow, col: newCol } });
                            }
                        }
                    }

                    // Check for regular moves (only if not forced to capture)
                    if (!onlyJumps && !this.mustCapture) {
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8 && !currentBoard[newRow][newCol]) {
                            if (piece.type === 'pawn') { // Pawns only move one step
                                moves.push({ row: newRow, col: newCol, isJump: false });
                            } else if (piece.type === 'king') { // Kings can move multiple steps (simplified)
                                // For multi-step king moves, ensure path is clear
                                let pathClear = true;
                                for (let i = 1; i <= Math.max(Math.abs(dir.dr), Math.abs(dir.dc)); i++) {
                                    const intermediateRow = start.row + dir.dr * i;
                                    const intermediateCol = start.col + dir.dc * i;
                                    if (intermediateRow === newRow && intermediateCol === newCol) continue; // Skip target square
                                    if (currentBoard[intermediateRow]?.[intermediateCol]) {
                                        pathClear = false;
                                        break;
                                    }
                                }
                                if (pathClear) {
                                    moves.push({ row: newRow, col: newCol, isJump: false });
                                }
                            }
                        }
                    }
                });

                // If there are any jumps available, only return jumps (mandatory capture)
                const jumpMoves = moves.filter(move => move.isJump);
                if (jumpMoves.length > 0) {
                    return jumpMoves;
                } else if (onlyJumps) { // If specifically asked for only jumps and none found
                    return [];
                }
                return moves;
            },

            // AI for Checkers (Very Basic: Prioritize captures, otherwise random legal move)
            findBestMove: function() {
                const allLegalMoves = [];
                let captureMoves = [];

                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece && piece.color === this.AI_PLAYER_COLOR) {
                            const pieceMoves = this.getValidMoves({ row: r, col: c }, this.board, false); // Get all moves
                            pieceMoves.forEach(move => {
                                const fullMove = { start: { row: r, col: c }, end: move };
                                allLegalMoves.push(fullMove);
                                if (move.isJump) {
                                    captureMoves.push(fullMove);
                                }
                            });
                        }
                    }
                }

                // Prioritize captures
                if (captureMoves.length > 0) {
                    // For multi-jumps, AI needs to continue with the same piece
                    if (this.lastJumpedPiece) {
                        const furtherJumps = captureMoves.filter(m => m.start.row === this.lastJumpedPiece.row && m.start.col === this.lastJumpedPiece.col);
                        if (furtherJumps.length > 0) {
                            return furtherJumps[Math.floor(Math.random() * furtherJumps.length)]; // Pick random among current piece's jumps
                        }
                    }
                    return captureMoves[Math.floor(Math.random() * captureMoves.length)]; // Pick random capture
                } else if (allLegalMoves.length > 0) {
                    // If no captures, pick a random non-capture move
                    const nonCaptureMoves = allLegalMoves.filter(move => !move.end.isJump);
                    if (nonCaptureMoves.length > 0) {
                        return nonCaptureMoves[Math.floor(Math.random() * nonCaptureMoves.length)];
                    }
                    // Fallback in case only jumps were generated but not taken (shouldn't happen with mandatory capture logic)
                    return allLegalMoves[Math.floor(Math.random() * allLegalMoves.length)];
                }
                return null; // No legal moves
            },

            makeAIMove: async function() {
                statusMessageElement.textContent = "AI (Black) is thinking...";
                this.disableInteraction();
                await new Promise(resolve => setTimeout(resolve, 1000));

                let move = this.findBestMove();
                let multiJumpActive = false;

                do {
                    if (!move) {
                        console.log("AI has no legal moves. Game over!");
                        statusMessageElement.textContent = "AI has no legal moves. Game over!";
                        break;
                    }

                    let capturedPieceInfo = null;
                    if (move.end.isJump) {
                        capturedPieceInfo = { row: move.end.captured.row, col: move.end.captured.col, pieceClass: 'checkers-piece' };
                    }

                    const moveSuccessfulResult = await animateAndMovePiece(
                        move.start,
                        move.end,
                        this.board,
                        'checkers-piece',
                        this.updateBoardStateAndRender.bind(this),
                        capturedPieceInfo
                    );

                    if (moveSuccessfulResult && moveSuccessfulResult.isJump) {
                        const furtherJumps = this.getValidMoves(move.end, this.board, true);
                        if (furtherJumps.length > 0) {
                            this.lastJumpedPiece = move.end; // Set for next AI iteration
                            this.mustCapture = true;
                            move = this.findBestMove(); // Find next jump for same piece
                            multiJumpActive = true;
                            await new Promise(resolve => setTimeout(resolve, PIECE_ANIMATION_SPEED_MS + 300)); // Short pause between jumps
                        } else {
                            multiJumpActive = false;
                        }
                    } else {
                        multiJumpActive = false;
                    }

                } while (multiJumpActive); // Continue looping if multi-jump is active

                this.isAITurn = false;
                this.mustCapture = false; // Reset after AI turn
                this.lastJumpedPiece = null;
                this.enableInteraction();
                this.renderBoard();
            },

            disableInteraction: function() {
                document.getElementById(this.boardId).style.pointerEvents = 'none';
                newGameBtn.disabled = true;
                resetBtn.disabled = true;
                settingsBtn.disabled = true;
                mainMenuAccessBtn.disabled = true;
            },

            enableInteraction: function() {
                document.getElementById(this.boardId).style.pointerEvents = 'auto';
                newGameBtn.disabled = false;
                resetBtn.disabled = false;
                settingsBtn.disabled = false;
                mainMenuAccessBtn.disabled = false;
            }
        };

        // --- Blackjack Game Logic ---
        const blackjackGame = {
            gameId: 'blackjack-game-container',
            deck: [],
            playerHand: [],
            dealerHand: [],
            playerScore: 0,
            dealerScore: 0,
            playerChips: 200, // New: Player's starting chips
            currentBet: 0,    // New: Current bet for the round
            isGameActive: false,

            initializeGame: function() {
                console.log("Initializing Blackjack game...");
                this.deck = this.createDeck();
                this.shuffleDeck(this.deck);
                this.playerHand = [];
                this.dealerHand = [];
                this.playerScore = 0;
                this.dealerScore = 0;
                this.isGameActive = false;
                this.currentBet = 0; // Reset bet for a new game

                // Clear hands visually before dealing new cards
                playerHandElement.innerHTML = '';
                dealerHandElement.innerHTML = '';
                playerScoreElement.textContent = `Score: 0`;
                dealerScoreElement.textContent = `Score: 0`;

                this.updateUI(); // Update chips display
                blackjackStatusMessageElement.textContent = "Enter your bet and click Deal!";
                dealBtn.disabled = false;
                hitBtn.disabled = true;
                standBtn.disabled = true;
                betAmountInput.disabled = false;
                betAmountInput.value = Math.min(10, this.playerChips); // Set default bet, cap at current chips
                betAmountInput.max = this.playerChips; // Update max bet based on chips
            },

            createDeck: function() {
                const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
                const suits = ['♠', '♥', '♦', '♣'];
                const deck = [];
                for (const suit of suits) {
                    for (const rank of ranks) {
                        deck.push({ rank, suit });
                    }
                }
                return deck;
            },

            shuffleDeck: function(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            },

            getCardValue: function(card) {
                if (['J', 'Q', 'K'].includes(card.rank)) {
                    return 10;
                }
                if (card.rank === 'A') {
                    return 11; // Will handle 1 or 11 logic later
                }
                return parseInt(card.rank);
            },

            calculateHandScore: function(hand) {
                let score = 0;
                let numAces = 0;
                for (const card of hand) {
                    score += this.getCardValue(card);
                    if (card.rank === 'A') {
                        numAces++;
                    }
                }
                while (score > 21 && numAces > 0) {
                    score -= 10; // Convert an Ace from 11 to 1
                    numAces--;
                }
                return score;
            },

            dealCard: function(hand, isHidden = false) {
                if (this.deck.length === 0) {
                    this.deck = this.createDeck(); // Reshuffle if deck runs out
                    this.shuffleDeck(this.deck);
                    blackjackStatusMessageElement.textContent = "Deck reshuffled!";
                }
                const card = this.deck.pop();
                hand.push({ ...card, isHidden });
                return card;
            },

            // New function to add a card to the UI with animation
            addCardToHandUI: function(card, handElement, isHidden = false) {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('card', 'dealing'); // Add dealing class for animation
                if (isHidden) {
                    cardDiv.classList.add('hidden-card');
                    cardDiv.innerHTML = `<div class="card-back-text"></div>`; // Placeholder for back of card
                } else {
                    const isRedSuit = card.suit === '♥' || card.suit === '♦';
                    cardDiv.innerHTML = `
                        <div class="card-suit top-left ${isRedSuit ? 'red' : ''}">${card.suit}</div>
                        <div class="card-rank">${card.rank}</div>
                        <div class="card-suit ${isRedSuit ? 'red' : ''}">${card.suit}</div>
                    `;
                }
                handElement.appendChild(cardDiv);

                // Remove the 'dealing' class after animation to reset state
                setTimeout(() => {
                    cardDiv.classList.remove('dealing');
                }, 400); // Matches animation duration
            },

            renderHand: function(hand, element, isDealerHand = false) {
                // This function is now mainly for initial setup or full re-renders without animation
                element.innerHTML = '';
                hand.forEach((card, index) => {
                    const cardDiv = document.createElement('div');
                    cardDiv.classList.add('card');
                    if (card.isHidden && isDealerHand && index === 0) { // Only hide the first dealer card
                        cardDiv.classList.add('hidden-card');
                        cardDiv.innerHTML = `<div class="card-back-text"></div>`; // Placeholder for back of card
                    } else {
                        const isRedSuit = card.suit === '♥' || card.suit === '♦';
                        cardDiv.innerHTML = `
                            <div class="card-suit top-left ${isRedSuit ? 'red' : ''}">${card.suit}</div>
                            <div class="card-rank">${card.rank}</div>
                            <div class="card-suit ${isRedSuit ? 'red' : ''}">${card.suit}</div>
                        `;
                    }
                    element.appendChild(cardDiv);
                });
            },

            updateUI: function(revealDealerCard = false) {
                // This function now primarily updates scores and chip counts,
                // and handles the revealing of the dealer's first card.
                playerScoreElement.textContent = `Score: ${this.calculateHandScore(this.playerHand)}`;

                if (revealDealerCard) {
                    // The actual card content update and class removal for flip animation is handled in dealerTurn
                    dealerScoreElement.textContent = `Score: ${this.calculateHandScore(this.dealerHand)}`;
                } else {
                    if (this.dealerHand.length > 0 && !this.dealerHand[0].isHidden) {
                        dealerScoreElement.textContent = `Score: ${this.calculateHandScore(this.dealerHand)}`;
                    } else {
                        dealerScoreElement.textContent = `Score: ?`;
                    }
                }
                playerChipsElement.textContent = `Chips: $${this.playerChips}`;
                betAmountInput.max = this.playerChips; // Update max bet
                if (this.playerChips <= 0) {
                    blackjackStatusMessageElement.textContent = "Game Over! You ran out of chips.";
                    dealBtn.disabled = true;
                    betAmountInput.disabled = true;
                    hitBtn.disabled = true;
                    standBtn.disabled = true;
                }
            },

            placeBet: function() {
                const bet = parseInt(betAmountInput.value);

                if (isNaN(bet) || bet <= 0) {
                    blackjackStatusMessageElement.textContent = "Please enter a valid bet amount.";
                    return;
                }
                if (bet > this.playerChips) {
                    blackjackStatusMessageElement.textContent = "You don't have enough chips for that bet!";
                    return;
                }
                // No arbitrary max bet for now, let it be limited by playerChips

                this.currentBet = bet;
                this.playerChips -= bet; // Deduct bet from chips
                this.updateUI(); // Update chips display immediately

                blackjackStatusMessageElement.textContent = `Bet of $${this.currentBet} placed. Dealing cards...`;
                betAmountInput.disabled = true;
                dealBtn.disabled = true; // Disable deal button until round ends
                this.dealInitialCards();
            },

            dealInitialCards: async function() {
                this.playerHand = [];
                this.dealerHand = [];
                this.isGameActive = true; // Set active early to prevent double bets

                // Disable buttons during dealing animation
                dealBtn.disabled = true;
                hitBtn.disabled = true;
                standBtn.disabled = true;
                betAmountInput.disabled = true;

                // Clear hands visually before dealing new cards
                playerHandElement.innerHTML = '';
                dealerHandElement.innerHTML = '';
                playerScoreElement.textContent = `Score: 0`;
                dealerScoreElement.textContent = `Score: ?`; // Keep dealer score hidden initially

                blackjackStatusMessageElement.textContent = `Bet of $${this.currentBet} placed. Dealing cards...`;

                // Deal player's first card
                const playerCard1 = this.dealCard(this.playerHand);
                this.addCardToHandUI(playerCard1, playerHandElement);
                this.playerScore = this.calculateHandScore(this.playerHand);
                playerScoreElement.textContent = `Score: ${this.playerScore}`;
                await new Promise(resolve => setTimeout(resolve, 500)); // Delay for animation

                // Deal dealer's first card (hidden)
                const dealerCard1 = this.dealCard(this.dealerHand, true);
                this.addCardToHandUI(dealerCard1, dealerHandElement, true);
                await new Promise(resolve => setTimeout(resolve, 500));

                // Deal player's second card
                const playerCard2 = this.dealCard(this.playerHand);
                this.addCardToHandUI(playerCard2, playerHandElement);
                this.playerScore = this.calculateHandScore(this.playerHand);
                playerScoreElement.textContent = `Score: ${this.playerScore}`;
                await new Promise(resolve => setTimeout(resolve, 500));

                // Deal dealer's second card (visible)
                const dealerCard2 = this.dealCard(this.dealerHand);
                this.addCardToHandUI(dealerCard2, dealerHandElement);
                this.dealerScore = this.calculateHandScore(this.dealerHand); // Calculate full score but don't display yet
                await new Promise(resolve => setTimeout(resolve, 500));

                // After all initial cards are dealt and animated
                // No need to call updateUI(true) here, as dealer's first card is still hidden
                // this.updateUI(); // This will update chips and player score, but dealer score remains '?'

                if (this.playerScore === 21) {
                    this.endGame("Blackjack! You win!");
                } else {
                    hitBtn.disabled = false;
                    standBtn.disabled = false;
                    blackjackStatusMessageElement.textContent = "Hit or Stand?";
                }
            },

            playerHit: async function() {
                if (!this.isGameActive) return;

                hitBtn.disabled = true; // Disable during hit animation
                standBtn.disabled = true;

                const newCard = this.dealCard(this.playerHand);
                this.addCardToHandUI(newCard, playerHandElement);
                this.playerScore = this.calculateHandScore(this.playerHand);
                playerScoreElement.textContent = `Score: ${this.playerScore}`;

                await new Promise(resolve => setTimeout(resolve, 500)); // Wait for card animation

                if (this.playerScore > 21) {
                    this.endGame("Bust! You lose.");
                } else if (this.playerScore === 21) {
                    this.dealerTurn();
                } else {
                    hitBtn.disabled = false;
                    standBtn.disabled = false;
                }
            },

            playerStand: function() {
                if (!this.isGameActive) return;
                this.dealerTurn();
            },

            dealerTurn: async function() {
                this.isGameActive = false;
                hitBtn.disabled = true;
                standBtn.disabled = true;

                // Find the hidden dealer card element (which is always the first one)
                const hiddenCardElement = dealerHandElement.querySelector('.card.hidden-card');
                if (hiddenCardElement) {
                    hiddenCardElement.classList.add('flipping'); // Add flipping animation class
                    // Update content after half the animation to simulate flip
                    setTimeout(() => {
                        const hiddenCardData = this.dealerHand[0]; // This is the hidden card object
                        const isRedSuit = hiddenCardData.suit === '♥' || hiddenCardData.suit === '♦';
                        hiddenCardElement.innerHTML = `
                            <div class="card-suit top-left ${isRedSuit ? 'red' : ''}">${hiddenCardData.suit}</div>
                            <div class="card-rank">${hiddenCardData.rank}</div>
                            <div class="card-suit ${isRedSuit ? 'red' : ''}">${hiddenCardData.suit}</div>
                        `;
                        hiddenCardElement.classList.remove('hidden-card'); // Remove hidden class
                    }, 300); // Half of flip-card animation duration (0.6s / 2)

                    await new Promise(resolve => setTimeout(resolve, 600)); // Wait for flip animation to complete
                    hiddenCardElement.classList.remove('flipping'); // Remove animation class
                }
                this.dealerHand[0].isHidden = false; // Update internal state

                this.updateUI(true); // Update UI to show revealed card and score

                // Dealer hits logic with delays
                while (this.calculateHandScore(this.dealerHand) < 17) {
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Delay between dealer hits
                    const newCard = this.dealCard(this.dealerHand);
                    this.addCardToHandUI(newCard, dealerHandElement);
                    this.dealerScore = this.calculateHandScore(this.dealerHand);
                    dealerScoreElement.textContent = `Score: ${this.dealerScore}`;
                    await new Promise(resolve => setTimeout(resolve, 500)); // Wait for card animation
                }
                this.determineWinner();
            },

            determineWinner: function() {
                const playerScore = this.calculateHandScore(this.playerHand);
                const dealerScore = this.calculateHandScore(this.dealerHand);
                let message = "";

                if (playerScore > 21) {
                    message = "You busted! Dealer wins.";
                    // Chips already deducted
                } else if (dealerScore > 21) {
                    message = "Dealer busts! You win!";
                    this.playerChips += this.currentBet * 2; // Win: get back bet + same amount
                } else if (playerScore > dealerScore) {
                    message = "You win!";
                    this.playerChips += this.currentBet * 2; // Win: get back bet + same amount
                } else if (dealerScore > playerScore) {
                    message = "Dealer wins!";
                    // Chips already deducted
                } else {
                    message = "It's a push (tie)!";
                    this.playerChips += this.currentBet; // Push: get back bet
                }
                this.endGame(message);
            },

            endGame: function(message) {
                this.isGameActive = false;
                hitBtn.disabled = true;
                standBtn.disabled = true;
                dealBtn.disabled = false; // Enable deal button for next round
                betAmountInput.disabled = false; // Enable bet input for next round
                blackjackStatusMessageElement.textContent = message;
                this.updateUI(true); // Ensure all cards are revealed at end of game
                this.currentBet = 0; // Reset current bet
            },

            disableInteraction: function() {
                dealBtn.disabled = true;
                hitBtn.disabled = true;
                standBtn.disabled = true;
                betAmountInput.disabled = true;
            },

            enableInteraction: function() {
                // Only enable deal/bet if game is not active and player has chips
                if (!this.isGameActive && this.playerChips > 0) {
                    dealBtn.disabled = false;
                    betAmountInput.disabled = false;
                    betAmountInput.max = this.playerChips; // Update max bet
                    betAmountInput.value = Math.min(parseInt(betAmountInput.value || 0), this.playerChips); // Adjust current value if needed, handle NaN
                }
                // Hit/Stand remain disabled until a hand is dealt
            }
        };


        // --- Game Management (Global) ---

        // Initial setup for the board elements
        // These elements exist in the HTML and we will just toggle their visibility
        const chessboardElement = document.getElementById('chessboard');
        const checkersboardElement = document.getElementById('checkersboard');
        // Blackjack container already exists in HTML

        function hideAllGameBoards() {
            chessboardElement.classList.add('hidden-board');
            checkersboardElement.classList.add('hidden-board');
            blackjackGameContainer.classList.add('hidden-board');

            // Explicitly remove display properties that might interfere
            chessboardElement.style.display = '';
            checkersboardElement.style.display = '';
            blackjackGameContainer.style.display = '';
        }

        function showGameBoard(boardId) {
            hideAllGameBoards(); // First hide all to ensure clean slate
            const boardElement = document.getElementById(boardId);
            boardElement.classList.remove('hidden-board');

            // Apply specific display properties based on board type
            if (boardId === 'chessboard' || boardId === 'checkersboard') {
                boardElement.style.display = 'grid';
            } else if (boardId === 'blackjack-game-container') {
                boardElement.style.display = 'flex';
            }
        }

        function startGame(gameType) {
            console.log(`Attempting to start ${gameType} game.`);
            gameInProgress = true;
            menuContinueGameBtn.disabled = false; // Enable continue game button

            switch (gameType) {
                case 'chess':
                    currentGame = chessGame;
                    gameTitleElement.textContent = 'Chess';
                    chessGame.initializeBoard(); // Re-initialize board state
                    chessGame.renderBoard();     // Re-render the existing board element
                    showGameBoard('chessboard');
                    statusMessageElement.style.display = 'block'; // Ensure status message is visible for board games
                    break;
                case 'checkers':
                    currentGame = checkersGame;
                    gameTitleElement.textContent = 'Checkers';
                    checkersGame.initializeBoard(); // Re-initialize board state
                    checkersGame.renderBoard();     // Re-render the existing board element
                    showGameBoard('checkersboard');
                    statusMessageElement.style.display = 'block'; // Ensure status message is visible for board games
                    break;
                case 'blackjack':
                    currentGame = blackjackGame;
                    gameTitleElement.textContent = 'Blackjack';
                    blackjackGame.initializeGame(); // This will handle initial UI setup for blackjack
                    showGameBoard('blackjack-game-container');
                    statusMessageElement.style.display = 'none'; // Hide main status message for Blackjack
                    break;
                default:
                    console.error("Unknown game type:", gameType);
                    gameInProgress = false;
                    menuContinueGameBtn.disabled = true;
                    return;
            }
            closeMainMenu(); // Close main menu after starting a game
            if (currentGame && currentGame.enableInteraction) { // Ensure interaction is enabled for the new game
                currentGame.enableInteraction();
            }
            console.log(`Successfully started ${gameType} game.`);
        }

        function resetCurrentGame() {
            if (currentGame) {
                if (currentGame === chessGame) {
                    chessGame.initializeBoard();
                    chessGame.renderBoard();
                } else if (currentGame === checkersGame) {
                    checkersGame.initializeBoard();
                    checkersGame.renderBoard();
                } else if (currentGame === blackjackGame) {
                    // For blackjack, a full reset implies resetting chips too
                    blackjackGame.playerChips = 200; // Reset chips to 200 on explicit "Reset Board" for Blackjack
                    blackjackGame.initializeGame();
                }
                statusMessageElement.textContent = "Game reset!";
                if (currentGame && currentGame.enableInteraction) {
                    currentGame.enableInteraction();
                }
            }
        }

        // --- Main Menu Logic ---
        function openMainMenu() {
            mainMenuModal.classList.add('active');
            updateMainMenuButtons();
            // Disable game interaction when main menu is open
            if (currentGame && currentGame.disableInteraction) {
                currentGame.disableInteraction();
            }
        }

        function closeMainMenu() {
            mainMenuModal.classList.remove('active');
            // Re-enable game interaction if a game is in progress
            if (gameInProgress && currentGame && currentGame.enableInteraction) {
                currentGame.enableInteraction();
            }
        }

        function updateMainMenuButtons() {
            if (gameInProgress) {
                menuContinueGameBtn.disabled = false;
            } else {
                menuContinueGameBtn.disabled = true;
            }
        }

        // --- Settings Modal Logic ---
        function openSettingsMenu() {
            settingsModal.classList.add('active');
            // Disable game interaction when settings is open
            if (currentGame && currentGame.disableInteraction) {
                currentGame.disableInteraction();
            }
        }

        function closeSettingsMenu() {
            settingsModal.classList.remove('active');
            // Re-enable game interaction if a game is in progress
            if (gameInProgress && currentGame && currentGame.enableInteraction) {
                currentGame.enableInteraction();
            }
        }

        // Function to load initial settings (e.g., from local storage or defaults)
        function loadSettings() {
            // Load AI Difficulty
            const savedAIDifficulty = localStorage.getItem('aiDifficulty');
            if (savedAIDifficulty) {
                AI_DIFFICULTY_DEPTH = parseInt(savedAIDifficulty);
                aiDifficultySelect.value = savedAIDifficulty;
            } else {
                aiDifficultySelect.value = AI_DIFFICULTY_DEPTH; // Set default in UI
            }
            aiDifficultySelect.addEventListener('change', (event) => {
                AI_DIFFICULTY_DEPTH = parseInt(event.target.value);
                localStorage.setItem('aiDifficulty', AI_DIFFICULTY_DEPTH);
                console.log("AI Difficulty set to depth:", AI_DIFFICULTY_DEPTH);
            });


            // Load Animation Speed
            const savedAnimationSpeed = localStorage.getItem('animationSpeed');
            if (savedAnimationSpeed) {
                PIECE_ANIMATION_SPEED_MS = parseInt(savedAnimationSpeed);
                animationSpeedSlider.value = savedAnimationSpeed;
            } else {
                animationSpeedSlider.value = PIECE_ANIMATION_SPEED_MS; // Set default in UI
            }
            // Trigger initial display update for animation speed
            animationSpeedSlider.dispatchEvent(new Event('input'));

            animationSpeedSlider.addEventListener('input', (event) => {
                PIECE_ANIMATION_SPEED_MS = parseInt(event.target.value);
                const speedSeconds = (PIECE_ANIMATION_SPEED_MS / 1000).toFixed(1);
                animationSpeedValueSpan.textContent = `${speedSeconds}s`;
                document.documentElement.style.setProperty('--piece-animation-speed', `${PIECE_ANIMATION_SPEED_MS / 1000}s`);
                localStorage.setItem('animationSpeed', PIECE_ANIMATION_SPEED_MS);
                console.log("Piece Animation Speed set to:", PIECE_ANIMATION_SPEED_MS, "ms");
            });
        }


        // --- Event Listeners (Global) ---
        newGameBtn.addEventListener('click', () => {
            if (currentGame) {
                startGame(currentGame.gameId === 'chessboard' ? 'chess' : (currentGame.gameId === 'checkersboard' ? 'checkers' : 'blackjack')); // Restart current game type
            } else {
                openMainMenu(); // If no game active, go to main menu to choose
            }
        });
        resetBtn.addEventListener('click', resetCurrentGame);
        settingsBtn.addEventListener('click', openSettingsMenu);
        mainMenuAccessBtn.addEventListener('click', openMainMenu);


        // Main Menu Button Listeners
        menuPlayChessBtn.addEventListener('click', () => {
            console.log("Play Chess button clicked.");
            startGame('chess');
        });
        menuPlayCheckersBtn.addEventListener('click', () => {
            console.log("Play Checkers button clicked.");
            startGame('checkers');
        });
        menuPlayBlackjackBtn.addEventListener('click', () => { // New Blackjack button listener
            console.log("Play Blackjack button clicked.");
            startGame('blackjack');
        });
        menuContinueGameBtn.addEventListener('click', closeMainMenu);
        menuSettingsBtn.addEventListener('click', () => {
            closeMainMenu();
            openSettingsMenu();
        });

        // Settings Modal Button Listeners
        closeSettingsBtn.addEventListener('click', closeSettingsMenu);

        // Close modals if clicked outside content
        settingsModal.addEventListener('click', (event) => {
            if (event.target === settingsModal) { closeSettingsMenu(); }
        });
        mainMenuModal.addEventListener('click', (event) => {
            if (event.target === mainMenuModal) { closeMainMenu(); }
        });

        // Blackjack specific button listeners
        dealBtn.addEventListener('click', () => blackjackGame.placeBet()); // Now calls placeBet first
        hitBtn.addEventListener('click', () => blackjackGame.playerHit());
        standBtn.addEventListener('click', () => blackjackGame.playerStand());
        blackjackNewGameBtn.addEventListener('click', () => {
             blackjackGame.playerChips = 200; // Reset chips to 200 on explicit "New Game" for Blackjack
             blackjackGame.initializeGame();
        });


        // Initial setup on page load
        window.onload = () => {
            loadSettings(); // Load settings first
            openMainMenu(); // Open main menu on load
            // Game will start when user clicks "Start New Game" from menu
        };

    </script>
</body>
</html>
